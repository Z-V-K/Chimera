#include "LuaExporter.h"

#include "LuaIncludes.h"

#include "../../Framework/Enums/EventType.h"
#include "../../Framework/GameEngine/ObjectManager/ObjectManager.h"
#include "../../Framework/Navigation/NavMesh/NavMesh.h"
#include "../../Impl/EntityList/EntityList.h"
#include "../../Impl/Managers/EventManager/EventManager.h"
#include "../Framework/GameObjects/GameObject/GameObject.h"
#include "../../Framework/GameEngine/GameTime/GameTime.h"
#include "../../Framework/GameEngine/NetClient/NetClient.h"
#include "../../Framework/Hud/Chat/Chat.h"
#include "../../Framework/Hud/Hud/Hud.h"
#include "../../Framework/Hud/Minimap/Minimap.h"
#include "../../Framework/Rendering/r3dRenderer/r3dRenderer.h"
#include "../../Impl/Input/Input.h"
#include "../../Impl/Managers/DmgLibManager/DamageLibManager.h"
#include "../../Impl/Managers/DrawManager/DrawManager.h"
#include "../../Impl/Managers/GlowManager/GlowManager.h"
#include "../../Impl/Managers/HealthPredManager/HealthPredictionManager.h"
#include "../../Impl/Managers/MenuManager/MenuManager.h"
#include "../../Impl/Managers/OrbwalkerManager/OrbwalkerManager.h"
#include "../../Impl/Managers/PermashowManager/PermashowManager.h"
#include "../../Impl/Managers/TargetSelectorManager/TargetSelectorManager.h"
#include "../../Impl/Scheduler/Scheduler.h"
#include "../../Impl/UI/Permashow/Permashow.h"

using namespace luabridge;

GameObject* get_local_player()
{
    return GameObject::get_local_player();
}

void LuaExporter::export_texture(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<LuaTexture>(xorstr_("texture"))
        .endClass();
}

void LuaExporter::export_globals(lua_State* state)
{
    getGlobalNamespace(state)
        .addFunction(xorstr_("log"), [](const char* t){ g_ctx->mConsole->log(t); })
        .addFunction(xorstr_("err"), [](const char* t){ g_ctx->mConsole->log_error(t); })
        .addFunction(xorstr_("warn"), [](const char* t){ g_ctx->mConsole->log_warning(t); })
        .addFunction(xorstr_("info"), [](const char* t){ g_ctx->mConsole->log_info(t); })
        .addFunction(xorstr_("dbg"), [](const char* t){ g_ctx->mConsole->log_debug(t); });

    GameObject* local_player = GameObject::get_local_player();
    setGlobal(state, local_player, xorstr_("player"));
}
void LuaExporter::export_entitylist(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("entities"))
			.addProperty(xorstr_("heroes"), []() { return g_entityList->get_heroes(); })
	        .addProperty(xorstr_("minions"), []() { return g_entityList->get_minions(); })
	        .addProperty(xorstr_("turrets"), []() { return g_entityList->get_turrets(); })
	        .addProperty(xorstr_("ally_turrets"), []() { return g_entityList->get_ally_turrets(); })
	        .addProperty(xorstr_("enemy_turrets"), []() { return g_entityList->get_enemy_turrets(); })
	        .addProperty(xorstr_("inhibitors"), []() { return g_entityList->get_inhibitors(); })
	        .addProperty(xorstr_("ally_inhibitors"), []() { return g_entityList->get_ally_inhibitors(); })
	        .addProperty(xorstr_("enemy_inhibitors"), []() { return g_entityList->get_enemy_inhibitors(); })
	        .addProperty(xorstr_("nexus"), []() { return g_entityList->get_nexus(); })
	        .addProperty(xorstr_("ally_nexus"), []() { return g_entityList->get_ally_nexus(); })
	        .addProperty(xorstr_("enemy_nexus"), []() { return g_entityList->get_enemy_nexus(); })
	        .addProperty(xorstr_("missiles"), []() { return g_entityList->get_missiles(); })
	        .addProperty(xorstr_("ally_missiles"), []() { return g_entityList->get_ally_missiles(); })
	        .addProperty(xorstr_("enemy_missiles"), []() { return g_entityList->get_enemy_missiles(); })
	        .addProperty(xorstr_("clones"), []() { return g_entityList->get_clones(); })
	        .addProperty(xorstr_("ally_clones"), []() { return g_entityList->get_ally_clones(); })
	        .addProperty(xorstr_("enemy_clones"), []() { return g_entityList->get_enemy_clones(); })
	        .addProperty(xorstr_("neutral_camps"), []() { return g_entityList->get_neutral_camps(); })
	        .addProperty(xorstr_("objects"), [](){ return g_entityList->get_all_objects(); })
        .endNamespace();
}
void LuaExporter::export_gameobject(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<GameObject>(xorstr_("gameobject"))
        .addProperty(xorstr_("type"), [](GameObject* self) { return (uint32_t)self->get_type(); })
        .addProperty(xorstr_("missile_client"), &GameObject::get_missile_client)
        .addProperty(xorstr_("pcc"), &GameObject::get_path_controller_common)
        .addProperty(xorstr_("basic_attack"), &GameObject::get_basic_attack)
        .addProperty(xorstr_("effect_hash"), &GameObject::get_effect_hash)
        .addProperty(xorstr_("emitter"), &GameObject::get_emitter)
        .addProperty(xorstr_("attachment"), &GameObject::get_attachment)
        .addProperty(xorstr_("target_attachment"), &GameObject::get_attachment)
        .addProperty(xorstr_("buffs"), &GameObject::get_buffs)
        .addProperty(xorstr_("items"), &GameObject::get_items)
        .addProperty(xorstr_("name"), &GameObject::get_name)
        .addProperty(xorstr_("model_name"), &GameObject::get_model_name)
        .addProperty(xorstr_("character_hash"), &GameObject::get_character_hash)
        .addProperty(xorstr_("circle_icon"), &GameObject::get_circle_icon_lua)
        .addProperty(xorstr_("square_icon"), &GameObject::get_square_icon_lua)
        .addProperty(xorstr_("position"), &GameObject::get_position)
        .addProperty(xorstr_("direction"), &GameObject::get_direction)
        .addProperty(xorstr_("hp_bar_pos"), &GameObject::get_health_bar_screen_position)
        .addProperty(xorstr_("owner_player"), &GameObject::get_owner_player)
        .addProperty(xorstr_("team"), [](GameObject* self) { return (int)self->get_team(); })
        .addProperty(xorstr_("index"), &GameObject::get_index)
        .addProperty(xorstr_("netid"), &GameObject::get_network_id)
        .addProperty(xorstr_("golds"), &GameObject::get_current_gold)
        .addProperty(xorstr_("visibility"), &GameObject::get_visibility)
        .addProperty(xorstr_("levelup_points"), &GameObject::get_level_up_points)
        .addProperty(xorstr_("level"), &GameObject::get_level)
        .addProperty(xorstr_("bounding"), &GameObject::get_bounding_radius)
        .addProperty(xorstr_("health"), &GameObject::get_health)
        .addProperty(xorstr_("max_health"), &GameObject::get_max_health)
        .addProperty(xorstr_("bonus_health"), &GameObject::get_bonus_health)
        .addProperty(xorstr_("bonus_mana"), &GameObject::get_bonus_mana)
        .addProperty(xorstr_("shield"), &GameObject::get_shield)
        .addProperty(xorstr_("magic_shield"), &GameObject::get_magic_shield)
        .addProperty(xorstr_("mana"), &GameObject::get_mana)
        .addProperty(xorstr_("max_mana"), &GameObject::get_max_mana)
        .addProperty(xorstr_("ability_haste"), &GameObject::get_ability_haste)
        .addProperty(xorstr_("lethality"), &GameObject::get_lethality)
        .addProperty(xorstr_("armor"), &GameObject::get_armor)
        .addProperty(xorstr_("bonus_armor"), &GameObject::get_bonus_armor)
        .addProperty(xorstr_("magic_res"), &GameObject::get_magic_res)
        .addProperty(xorstr_("bonus_magic_res"), &GameObject::get_bonus_magic_res)
        .addProperty(xorstr_("base_ad"), &GameObject::get_base_ad)
        .addProperty(xorstr_("movement_speed"), &GameObject::get_movement_speed)
        .addProperty(xorstr_("crit_damage_multiplier"), &GameObject::get_crit_damage_multiplier)
        .addProperty(xorstr_("crit"), &GameObject::get_crit)
        .addProperty(xorstr_("ap"), &GameObject::get_ap)
        .addProperty(xorstr_("bonus_ap_multiplier"), &GameObject::get_bonus_ap_multiplier)
        .addProperty(xorstr_("attack_speed_multiplier"), &GameObject::get_attack_speed_multiplier)
        .addProperty(xorstr_("attack_range"), &GameObject::get_attack_range)
        .addProperty(xorstr_("is_targetable"), &GameObject::is_targetable)
        .addProperty(xorstr_("accumulated_experience"), &GameObject::get_accumulated_experience)
        .addProperty(xorstr_("magic_pen_flat"), &GameObject::get_magic_pen_flat)
        .addProperty(xorstr_("armor_pen_multiplier"), &GameObject::get_armor_pen_multiplier)
        .addProperty(xorstr_("magic_pen_multiplier"), &GameObject::get_magic_pen_multiplier)
        .addProperty(xorstr_("mana_regen"), &GameObject::get_mana_regen)
        .addProperty(xorstr_("health_regen"), &GameObject::get_health_regen)
        .addProperty(xorstr_("attack_delay"), &GameObject::get_attack_delay)
        .addProperty(xorstr_("attack_cast_delay"), &GameObject::get_attack_cast_delay)
        .addProperty(xorstr_("is_invulnerable"), &GameObject::is_invulnerable)
        .addProperty(xorstr_("is_melee"), &GameObject::is_melee)
        .addProperty(xorstr_("is_ranged"), &GameObject::is_ranged)
        .addProperty(xorstr_("is_ally"), &GameObject::is_ally)
        .addProperty(xorstr_("is_enemy"), &GameObject::is_enemy)
        .addProperty(xorstr_("is_neutral"), &GameObject::is_neutral)
        .addProperty(xorstr_("is_visible"), &GameObject::is_visible)
        .addProperty(xorstr_("is_zombie"), &GameObject::is_zombie)
        .addProperty(xorstr_("is_recalling"), &GameObject::is_recalling)
        .addProperty(xorstr_("is_teleporting"), &GameObject::is_teleporting)
        .addProperty(xorstr_("is_me"), &GameObject::is_me)
        .addProperty(xorstr_("is_minion"), &GameObject::is_minion)
        .addProperty(xorstr_("is_lane_minion"), &GameObject::is_lane_minion)
        .addProperty(xorstr_("is_inhibitor"), &GameObject::is_inhibitor)
        .addProperty(xorstr_("is_nexus"), &GameObject::is_nexus)
        .addProperty(xorstr_("is_champion"), &GameObject::is_champion)
        .addProperty(xorstr_("is_turret"), &GameObject::is_turret)
        .addProperty(xorstr_("is_missile"), &GameObject::is_missile)
        .addProperty(xorstr_("is_neutral_camp"), &GameObject::is_neutral_camp)
        .addProperty(xorstr_("is_ward"), &GameObject::is_ward)
        .addProperty(xorstr_("is_baron"), &GameObject::is_baron)
        .addProperty(xorstr_("is_herald"), &GameObject::is_herald)
        .addProperty(xorstr_("is_dragon"), &GameObject::is_dragon)
        .addProperty(xorstr_("is_alive"), &GameObject::is_alive)
        .addProperty(xorstr_("is_plant"), &GameObject::is_plant)
        .addProperty(xorstr_("is_pet"), &GameObject::is_pet)
        .addProperty(xorstr_("is_practice_tool_dummy"), &GameObject::is_practice_tool_dummy)
        .addProperty(xorstr_("is_clone"), &GameObject::is_clone)
        .addProperty(xorstr_("turret_type"), &GameObject::get_turret_type)
        .addProperty(xorstr_("total_respawn_time"), &GameObject::get_total_respawn_time)
        .addProperty(xorstr_("remaining_respawn_time"), &GameObject::get_remaining_respawn_time)
        .addProperty(xorstr_("timer_expiry"), &GameObject::get_timer_expiry)
        .addProperty(xorstr_("gold_on_death"), &GameObject::get_gold_given_on_death)
        .addFunction(xorstr_("issue_order"), &GameObject::user_issue_order)
        .addFunction(xorstr_("cast_spell"), &GameObject::cast_spell)
        .addFunction(xorstr_("update_charged_spell"), &GameObject::update_charged_spell)
        .addFunction(xorstr_("has_item"), &GameObject::has_item)
        .addFunction(xorstr_("can_use_item"), &GameObject::can_use_item)
        .addFunction(xorstr_("get_item"), &GameObject::get_item)
        .addFunction(xorstr_("get_item_slot"), &GameObject::get_item_spell_slot)
        .addFunction(xorstr_("get_spell_slot_by_id"), &GameObject::get_spell_slot_by_id)
        .addFunction(xorstr_("get_spell_state"), [](GameObject* self, int slot) { return (int)self->get_spell_state((Enums::SpellSlot)slot); })
        .addFunction(xorstr_("can_use_spell"), &GameObject::can_use_spell)
        .addFunction(xorstr_("get_buff"), &GameObject::get_buff_by_hash)
        .addFunction(xorstr_("get_buffs_by_type"), [](GameObject* self, int type) { return self->get_buffs((Enums::BuffType) type); })
		.addFunction(xorstr_("get_buff_count"), [](GameObject* self, uint32_t hash) { return self->get_buff_count(hash); })
        .addFunction(xorstr_("is_visible_on_screen"), &GameObject::is_visible_on_screen)
		.addFunction(xorstr_("has_buff"), [](GameObject* self, uint32_t hash) { return self->has_buff(hash); })
        .addFunction(xorstr_("has_buff_type"), &GameObject::has_buff_type)
        .addFunction(xorstr_("is_facing"), &GameObject::is_facing)
        .addFunction(xorstr_("is_facing_obj"), &GameObject::is_facing_obj)
        .addFunction(xorstr_("is_in_range"), &GameObject::is_in_range)
        .addFunction(xorstr_("is_in_range_obj"), &GameObject::is_in_range_obj)
        .addFunction(xorstr_("is_in_auto_attack_range"), &GameObject::is_in_auto_attack_range)
        .addFunction(xorstr_("is_valid_target"), &GameObject::is_valid_target)
        .addFunction(xorstr_("cast_spell_self"), [](GameObject* self, Enums::SpellSlot slot){ GameObject::get_local_player()->cast_spell(slot, {}, {}, GameObject::get_local_player()); })
        .addFunction(xorstr_("cast_spell_target"), [](GameObject* self, Enums::SpellSlot slot, GameObject* target){ GameObject::get_local_player()->cast_spell(slot, {}, target->get_position(), target); })
        .addFunction(xorstr_("cast_spell_pos"), [](GameObject* self, Enums::SpellSlot slot, const Vec3& start_pos, const Vec3& end_pos){ GameObject::get_local_player()->cast_spell(slot, start_pos, end_pos, nullptr); })
        .addFunction(xorstr_("build_path"), [](GameObject* self, const Vec3& start, const Vec3& end, bool smooth = true){ self->get_path_controller_common()->build_navigation_path(start, end, smooth); })
    .endClass();
}
void LuaExporter::export_missileclient(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<MissileClient>(xorstr_("missileclient"))
            .addProperty(xorstr_("spell_data"), &MissileClient::get_spell_data)
            .addProperty(xorstr_("start_position"), &MissileClient::get_start_position)
            .addProperty(xorstr_("end_position"), &MissileClient::get_end_position)
            .addProperty(xorstr_("cast_position"), &MissileClient::get_cast_position)
			.addProperty(xorstr_("slot"), [](MissileClient* self) { return (int)self->get_slot(); })
            .addProperty(xorstr_("missile_index"), &MissileClient::get_missile_index)
            .addProperty(xorstr_("source"), &MissileClient::get_source)
            .addProperty(xorstr_("target"), &MissileClient::get_target)
        .endClass();
}
void LuaExporter::export_path_controller_common(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<PathControllerCommon>(xorstr_("pcc"))
            .addProperty(xorstr_("waypoints"), &PathControllerCommon::get_nav_waypoints)
            .addProperty(xorstr_("curr_segment"), &PathControllerCommon::get_curr_segment)
            .addProperty(xorstr_("start"), &PathControllerCommon::get_nav_start)
            .addProperty(xorstr_("end"), &PathControllerCommon::get_nav_end)
            .addProperty(xorstr_("nb_waypoints"), &PathControllerCommon::get_nb_waypoints)
            .addProperty(xorstr_("length"), &PathControllerCommon::get_path_length)
        .endClass();
}

void LuaExporter::export_obj_manager(lua_State* state)
{
    const auto obj_manager = ObjectManager::get_instance();
    
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("obj_manager"))
            .addFunction(xorstr_("find_netid"), [obj_manager](int netid){ return obj_manager->get_object_by_network_id(netid); })
            .addFunction(xorstr_("find"), [obj_manager](int index){ return obj_manager->find_object(index); })
        .endNamespace();
}

void LuaExporter::export_spellslot(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<SpellSlot>(xorstr_("spellslot"))
            .addProperty(xorstr_("spell_data"), &SpellSlot::get_spell_data)
            .addProperty(xorstr_("slot"), [](SpellSlot* self) { return (int)self->get_slot_id(); })
            .addProperty(xorstr_("ammo"), &SpellSlot::get_ammo)
            .addProperty(xorstr_("max_cooldown"), &SpellSlot::get_max_cooldown)
            .addProperty(xorstr_("level"), &SpellSlot::get_level)
            .addProperty(xorstr_("ready_at"), &SpellSlot::get_ready_at)
            .addProperty(xorstr_("damage"), &SpellSlot::get_damage)
            .addProperty(xorstr_("cooldown"), &SpellSlot::get_cooldown)
            .addProperty(xorstr_("ammo_ready_at"), &SpellSlot::get_ammo_ready_at)
            .addProperty(xorstr_("ammo_cooldown"), &SpellSlot::get_ammo_cooldown)
            .addProperty(xorstr_("icon"), &SpellSlot::get_icon_lua)
        .endClass();
}

void LuaExporter::export_spelldata(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<SpellData>(xorstr_("spelldata"))
            .addProperty(xorstr_("spell_name"), &SpellData::get_spell_name)
            .addProperty(xorstr_("hash"), &SpellData::get_hash)
            .addProperty(xorstr_("mSpellTags"), &SpellData::mSpellTags)
            .addProperty(xorstr_("mDataValues_BaseDamage"), &SpellData::mDataValues_BaseDamage)
            .addProperty(xorstr_("cooldownTime"), &SpellData::cooldownTime)
            .addProperty(xorstr_("delayCastOffsetPercent"), &SpellData::delayCastOffsetPercent)
            .addProperty(xorstr_("delayTotalTimePercent"), &SpellData::delayTotalTimePercent)
            .addProperty(xorstr_("mTurnSpeedScalar"), &SpellData::mTurnSpeedScalar)
            .addProperty(xorstr_("castRange"), &SpellData::castRange)
            .addProperty(xorstr_("castRangeDisplayOverride"), &SpellData::castRangeDisplayOverride)
            .addProperty(xorstr_("castRadius"), &SpellData::castRadius)
            .addProperty(xorstr_("castConeDistance"), &SpellData::castConeDistance)
            .addProperty(xorstr_("mMissileSpec_mMissileWidth"), &SpellData::mMissileSpec_mMissileWidth)
            .addProperty(xorstr_("castType"), &SpellData::castType)
            .addProperty(xorstr_("castFrame"), &SpellData::castFrame)
            .addProperty(xorstr_("missileSpeed"), &SpellData::missileSpeed)
            .addProperty(xorstr_("mLineWidth"), &SpellData::mLineWidth)
        .endClass();
}

void LuaExporter::export_itemslot(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<ItemSlot>(xorstr_("item"))
            .addProperty(xorstr_("stacks"), &ItemSlot::get_stacks)
            .addProperty(xorstr_("id"), [](ItemSlot* self) { return (int) self->get_item_id(); })
            .addProperty(xorstr_("price"), &ItemSlot::get_price)
            .addProperty(xorstr_("ability_haste"), &ItemSlot::get_ability_haste)
            .addProperty(xorstr_("health"), &ItemSlot::get_health)
            .addProperty(xorstr_("movement_speed"), &ItemSlot::get_movement_speed)
            .addProperty(xorstr_("armor"), &ItemSlot::get_armor)
            .addProperty(xorstr_("magic_resistance"), &ItemSlot::get_magic_resistance)
            .addProperty(xorstr_("ad"), &ItemSlot::get_ad)
            .addProperty(xorstr_("ap"), &ItemSlot::get_ap)
            .addProperty(xorstr_("attack_speed_multiplier"), &ItemSlot::get_attack_speed_multiplier)
            .addProperty(xorstr_("shield_power_multiplier"), &ItemSlot::get_shield_power_multiplier)
        .endClass();
}

void LuaExporter::export_spellcastinfo(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<SpellCastInfo>(xorstr_("spellcastinfo"))
            .addProperty(xorstr_("source"), &SpellCastInfo::get_source)
            .addProperty(xorstr_("target"), &SpellCastInfo::get_target)
            .addProperty(xorstr_("spell_data"), &SpellCastInfo::get_spell_data)
            .addProperty(xorstr_("start_pos"), &SpellCastInfo::get_start_pos)
            .addProperty(xorstr_("end_pos"), &SpellCastInfo::get_end_pos)
            .addProperty(xorstr_("cast_pos"), &SpellCastInfo::get_cast_pos)
            .addProperty(xorstr_("is_auto"), &SpellCastInfo::is_auto)
            .addProperty(xorstr_("is_spell"), &SpellCastInfo::is_spell)
            .addProperty(xorstr_("is_special_attack"), &SpellCastInfo::is_special_attack)
            .addProperty(xorstr_("slot"), [](SpellCastInfo* self) { return (int)self->get_slot(); })
            .addProperty(xorstr_("cast_delay"), &SpellCastInfo::get_cast_delay)
        .endClass();
}

void LuaExporter::export_buff(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<BuffEntry>(xorstr_("buff"))
            .addProperty(xorstr_("type"), [](BuffEntry* self) { return (int)self->get_type(); })
            .addProperty(xorstr_("count"), &BuffEntry::get_count)
            .addProperty(xorstr_("start_time"), &BuffEntry::get_start_time)
            .addProperty(xorstr_("end_time"), &BuffEntry::get_end_time)
            .addProperty(xorstr_("remaining_time"), &BuffEntry::get_remaining_time)
            .addProperty(xorstr_("total_duration"), &BuffEntry::get_total_duration)
            .addProperty(xorstr_("name"), &BuffEntry::get_name)
            .addProperty(xorstr_("hash"), &BuffEntry::get_hash)
            .addProperty(xorstr_("caster"), &BuffEntry::get_caster)
            .addProperty(xorstr_("owner"), &BuffEntry::get_owner)
        .endClass();
}

void LuaExporter::export_navmesh(lua_State* state)
{
    const auto nav_mesh = NavMesh::instance();
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("nav_mesh"))
            .addFunction(xorstr_("get_height"), [nav_mesh](const Vec3& pos){ return nav_mesh->get_height_for_position(pos); })
            .addFunction(xorstr_("get_flags"), [nav_mesh](const Vec3& pos){ return (int) nav_mesh->get_pos_flags(pos); })
            .addFunction(xorstr_("is_in_fow"), [nav_mesh](const Vec3& pos){ return nav_mesh->is_in_fow(pos); })
            .addFunction(xorstr_("set_pos_flags"), [nav_mesh](const Vec3& pos, uint16_t flag){ nav_mesh->set_pos_flags(pos, flag); })
        .endNamespace();
}

void LuaExporter::export_callbacks_manager(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("cb"))
            .addFunction(xorstr_("add"), [](int type, const LuaRef& func) { if (!func.isValid() || !func.isFunction()) return; g_event_manager->add_event((Enums::EventType)type, func);  })
            .addFunction(xorstr_("remove"), [](int type, const LuaRef& func) {if (!func.isValid() || !func.isFunction()) return; g_event_manager->remove_event((Enums::EventType)type, func);  })
            .addFunction(xorstr_("on_before_attack"), [](GameObject* target) { g_event_manager->fire_on_before_attack(target);  })
            .addFunction(xorstr_("on_after_attack"), [](GameObject* target) { g_event_manager->fire_on_after_attack(target);  })
            .addFunction(xorstr_("on_before_move"), [](Vec3* pos) { g_event_manager->fire_on_before_move(pos);  })
            .addFunction(xorstr_("on_after_move"), [](const Vec3& pos) { g_event_manager->fire_on_after_move(pos);  })
			.addProperty(xorstr_("tick"), []() { return (int)Enums::EventType::OnGameTick; })
            .addProperty(xorstr_("slowtick"), [] () { return (int) Enums::EventType::OnSlowTick; })
			.addProperty(xorstr_("draw"), []() { return (int) Enums::EventType::OnDraw; })
            .addProperty(xorstr_("create_obj"), [] () { return (int) Enums::EventType::OnCreateObject; })
            .addProperty(xorstr_("delete_obj"), [] () { return (int) Enums::EventType::OnDeleteObject; })
            .addProperty(xorstr_("process_spell"), [] () { return (int) Enums::EventType::OnProcessSpell; })
            .addProperty(xorstr_("issue_order"), [] () { return (int) Enums::EventType::OnIssueOrder; })
            .addProperty(xorstr_("cast_spell"), [] () { return (int) Enums::EventType::OnCastSpell; })
            .addProperty(xorstr_("stop_cast"), [] () { return (int) Enums::EventType::OnStopCast; })
            .addProperty(xorstr_("cast_complete"), [] () { return (int) Enums::EventType::OnCastComplete; })
            .addProperty(xorstr_("draw_env"), [] () { return (int) Enums::EventType::OnDrawEnvironment; })
            .addProperty(xorstr_("spell_impact"), [] () { return (int) Enums::EventType::OnSpellImpact; })
            .addProperty(xorstr_("play_anim"), [] () { return (int) Enums::EventType::OnPlayAnimation; })
            .addProperty(xorstr_("buff_gainlose"), [] () { return (int) Enums::EventType::OnBuffGainLose; })
            .addProperty(xorstr_("set_path"), [] () { return (int) Enums::EventType::OnSetPath; })
            .addProperty(xorstr_("process_auto"), [] () { return (int) Enums::EventType::OnProcessAutoAttack; })
            .addProperty(xorstr_("notify_event"), [] () { return (int) Enums::EventType::OnNotifyEvent; })
            .addProperty(xorstr_("before_attack_orb"), [] () { return (int) Enums::EventType::OnBeforeAttackOrbwalker; })
            .addProperty(xorstr_("after_attack_orb"), [] () { return (int) Enums::EventType::OnAfterAttackOrbwalker; })
            .addProperty(xorstr_("before_move_orb"), [] () { return (int) Enums::EventType::OnBeforeMoveOrbwalker; })
			.addProperty(xorstr_("after_move_orb"), []() { return (int)Enums::EventType::OnAfterMoveOrbwalker; })
        .endNamespace();
}

void LuaExporter::export_scheduler(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("scheduler"))
            .addFunction(xorstr_("add"), [](int ticks, const LuaRef& func) { if (!func.isValid() || !func.isFunction()) return; g_scheduler->delay_action(ticks, func); })
        .endNamespace();
}

void LuaExporter::export_draw_manager(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("draw"))
            .addFunction(xorstr_("screen_rectangle"), [] (const Vec2& p1, const Vec2& p2, D3DCOLOR col, float rounding = 0.f, float thickness = 1.f, bool filled = false) { g_draw_manager->screen_rectangle(p1, p2, col, rounding, thickness, filled); })
            .addFunction(xorstr_("rectangle_2points"), [] (const Vec3& start, const Vec3& end, D3DCOLOR color, const int width, const float rounding = 0.f, const float thickness = 0.f) { g_draw_manager->rectangle_2points(start, end, color, width, rounding); })
            .addFunction(xorstr_("rectangle_4points"), [] (const Vec3& p1, const Vec3& p2, const Vec3& p3, const Vec3& p4, D3DCOLOR color, const float thickness = 1.f) { g_draw_manager->rectangle_4points(p1, p2, p3, p4,color, thickness); })
            .addFunction(xorstr_("line"), [] (const Vec3& p1, const Vec3& p2, D3DCOLOR col, float thickness = 1.f) { g_draw_manager->line(p1, p2, col, thickness); })
            .addFunction(xorstr_("screen_line"), [] (const Vec2& p1, const Vec2& p2, D3DCOLOR col, float thickness = 1.f) { g_draw_manager->screen_line(p1, p2, col, thickness); })
            .addFunction(xorstr_("screen_text"), [] (const Vec2& pos, const std::string& text, D3DCOLOR color, int font_size = MenuSettings::get().font_size) { g_draw_manager->screen_text(pos, text, color, font_size); })
            .addFunction(xorstr_("text"), [] (const Vec3& pos, const std::string& text, D3DCOLOR color, int font_size) { g_draw_manager->text(pos, text, color, font_size); })
            .addFunction(xorstr_("texture"), [] (LuaTexture texture_ptr, const Vec2& pos, const Vec2& size, float rounding, const D3DCOLOR color = 0xFFFFFFFF, const Vec2& uv_min = Vec2(0, 0), const Vec2& uv_max = Vec2(1, 1)) { g_draw_manager->texture_lua(texture_ptr, pos, size, rounding, color, uv_min, uv_max); })
            .addFunction(xorstr_("screen_circle"), [] (const Vec2& center, const float radius, D3DCOLOR color, const float thickness = 1.f, const bool filled = false, const int num_points = 99) { g_draw_manager->screen_circle(center, radius, color, thickness, filled, num_points); })
            .addFunction(xorstr_("screen_circle_minimap"), [] (const Vec2& center, const float radius, D3DCOLOR color, const float thickness = 1.f, const int num_points = 99) { g_draw_manager->screen_circle_minimap(center, radius, color, thickness, num_points); })
            .addFunction(xorstr_("circle"), [] (const Vec3& center, const float radius, D3DCOLOR color, const float thickness = 1.f, bool filled = false, const int num_points = 99) { g_draw_manager->circle(center, radius, color, thickness, filled, num_points); })
            .addFunction(xorstr_("screen_arc"), [] (const Vec2& center, const float radius, const float a1, const float a2, const D3DCOLOR color, const float thickness = 1.f) { g_draw_manager->screen_arc(center, radius, a1, a2, color, thickness); })
            .addFunction(xorstr_("calc_text_size"), [] (const std::string& text, int font_size) { return g_draw_manager->calc_text_size(text, font_size); })
            .addFunction(xorstr_("color"), [] (int r, int g, int b, int a) { return g_draw_manager->rgba(r, g, b, a); })
        .endNamespace();
}

void LuaExporter::export_game(lua_State* state)
{
    const auto net_client = NetClient::get_instance();
    const auto hud = Hud::get_instance();
    
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("game"))
            .addProperty(xorstr_("time"), []{ return g_game_clock->get_time(); })
            .addProperty(xorstr_("tick_count"), []{ return g_game_clock->get_tick_count(); })
            .addProperty(xorstr_("ping"), [net_client]{ return net_client->get_ping(); })
            .addProperty(xorstr_("is_window_focused"), [hud]{ return hud->is_window_focused(); })
        .endNamespace();
}

void LuaExporter::export_minimap(lua_State* state)
{
    const auto minimap = Minimap::get_instance();

    getGlobalNamespace(state)
        .beginNamespace(xorstr_("minimap"))
            .addProperty(xorstr_("size"), [minimap] { return minimap->get_size(); })
            .addProperty(xorstr_("position"), [minimap] { return minimap->get_position(); })
        .endNamespace();
}

void LuaExporter::export_cursor(lua_State* state)
{
    const auto cursor = Hud::get_instance()->get_cursor();
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("cursor"))
            .addProperty(xorstr_("world_pos"), [cursor] { return cursor->get_world_position(); })
            .addProperty(xorstr_("screen_pos"), [] { return g_input->get_cursor_screen_position(); })
            .addProperty(xorstr_("last_click_pos"), [cursor] { return cursor->get_last_click_position(); })
            .addProperty(xorstr_("hovered_unit"), [cursor] { return cursor->get_hovered_unit(); })
        .endNamespace();
}

void LuaExporter::export_input(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("input"))
            .addFunction(xorstr_("is_key_down"), [](uint32_t key) { return g_input->is_key_down(key); })
            .addFunction(xorstr_("is_key_up"), [](uint32_t key) { return g_input->is_key_up(key); })
            .addFunction(xorstr_("is_key_pressed"), [](uint32_t key) { return g_input->is_key_pressed(key); })
        .endNamespace();
}

void LuaExporter::export_renderer(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("renderer"))
            .addProperty(xorstr_("size"), [] { return g_renderer->get_renderer_size(); })
        .addFunction(xorstr_("texture"), [](const std::string& str) { return g_renderer->get_texture_from_game_lua(str); })
        .endNamespace();
}

void LuaExporter::export_menu_item(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<MenuItem>(xorstr_("menuitem"))
            .addProperty(xorstr_("key"), &MenuItem::get_key)
        .addProperty(xorstr_("name"), &MenuItem::get_name)
        .addProperty(xorstr_("bool"), &MenuItem::get_bool, &MenuItem::set_bool)
        .addProperty(xorstr_("int"), &MenuItem::get_int, &MenuItem::set_int)
        .addProperty(xorstr_("col"), &MenuItem::get_color, &MenuItem::set_color)
        .addFunction(xorstr_("set_visible"), [](MenuItem* self, MenuItem* item) { self->set_visibility(item); })
        .addFunction(xorstr_("set_tooltip"), &MenuItem::set_tooltip)
        .addFunction(xorstr_("set_texture"), &MenuItem::set_texture_lua)
        .endClass();
}

void LuaExporter::export_menu(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<Menu>(xorstr_("menu"))
            .addProperty(xorstr_("key"), &Menu::get_key)
        .addProperty(xorstr_("name"), &Menu::get_name)
        .addFunction(xorstr_("menu"), &Menu::add_menu)
        .addFunction(xorstr_("separator"), &Menu::add_separator)
        .addFunction(xorstr_("checkbox"), &Menu::add_checkbox)
        .addFunction(xorstr_("slider"), &Menu::add_slider)
        .addFunction(xorstr_("color"), &Menu::add_color_pick)
        .addFunction(xorstr_("combo"), &Menu::add_combo)
        .addFunction(xorstr_("key"), &Menu::add_key)
        .addFunction(xorstr_("button"), &Menu::add_button)
        .addFunction(xorstr_("set_texture"), &Menu::set_texture_lua)
        .addFunction(xorstr_("set_enabled"), [](Menu* self, MenuItem* item) { self->set_enabled(item); })
        .addFunction(xorstr_("delete"), [](Menu* self, MenuItem* item) { return self->delete_item(item); })
        .addFunction(xorstr_("delete_key"), [](Menu* self, const std::string& key) { return self->delete_item(key); })
        .addFunction(xorstr_("get"), &Menu::get_item)
        .endClass();
            
}

void LuaExporter::export_menu_manager(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("menumanager"))
            .addFunction(xorstr_("create"), [](const std::string& key, const std::string& name, const std::string& icon = ICON_FA_BARS) { g_exported_menu_manager->create_menu(key, name, icon); })
        .addFunction(xorstr_("delete"), [](Menu* menu) { return g_exported_menu_manager->delete_menu(menu); })
        .addFunction(xorstr_("delete_key"), [](const std::string& key) { return g_exported_menu_manager->delete_menu(key); })
        .addFunction(xorstr_("get"), [](const std::string& key) { return g_exported_menu_manager->get_menu(key); })
        .addFunction(xorstr_("list"), [](){ return g_exported_menu_manager->get_menus(); } )
        .endNamespace();
}

void LuaExporter::export_chat(lua_State* state)
{
    const auto chat = Chat::instance();
    
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("chat"))
            .addFunction(xorstr_("print"), [chat](const std::string& msg) { chat->print_chat(msg); })
			.addFunction(xorstr_("send"), [chat](std::string msg){ chat->send_chat(msg, false); })
        .endNamespace();
}

void LuaExporter::export_damage_lib(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<DamageOutput>(xorstr_("damageoutput"))
            .addProperty(xorstr_("phy"), &DamageOutput::physical)
        .addProperty(xorstr_("mag"), &DamageOutput::magical)
        .addProperty(xorstr_("raw"), &DamageOutput::raw)
        .addProperty(xorstr_("total"), [](DamageOutput* self) { return self->physical + self->magical + self->raw; })
        .endClass()
        .beginNamespace(xorstr_("damage"))
            .addFunction(xorstr_("get_spell_damage"), [](GameObject* src, GameObject* target, Enums::SpellSlot slot, int stage = 1, int stacks = 1) { return g_damage_lib->get_damage(src, target, slot, stage, stacks); })
        .addFunction(xorstr_("get_auto_damage"), [](GameObject* src, GameObject* target, bool passive = true, bool items = true){ return g_damage_lib->get_auto_attack_damage(src, target, passive, items); })
        .endNamespace();
}

void LuaExporter::export_orbwalker(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("orb"))
            .addProperty(xorstr_("mode"), [] { return (int) g_orbwalker_manager->get_mode(); })
        .endNamespace();
}

void LuaExporter::export_evade(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("evade"))
        .endNamespace();
}

void LuaExporter::export_target_selector(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("ts"))
            .addFunction(xorstr_("get_target"), [] (float f, DamageType dmg, bool b) { return g_target_selector_manager->get_target(f, dmg, b); })
            .addFunction(xorstr_("get_target_filter"), [] (const std::vector<GameObject*>& list, DamageType dmg) { return g_target_selector_manager->get_target(list, dmg); })
            .addProperty(xorstr_("selected_target"), []{ return g_target_selector_manager->get_selected_target(); }, [](GameObject* obj) { g_target_selector_manager->set_selected_target(obj); })
        .endNamespace();
}

void LuaExporter::export_health_pred(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("health_pred"))
            .addFunction(xorstr_("predict"), [](GameObject* obj, int time, int delay = 70) { return g_health_pred_manager->get_health_prediction(obj, time, delay); })
            .addFunction(xorstr_("get_incoming_damage"), [](GameObject* obj, int time, int delay = 70) { return g_health_pred_manager->get_incoming_damage(obj, time, delay); })
            .addFunction(xorstr_("has_turret_aggro"), [](GameObject* obj) { return g_health_pred_manager->has_turret_aggro(obj); })
            .addFunction(xorstr_("has_minion_aggro"), [](GameObject* obj) { return g_health_pred_manager->has_minion_aggro(obj); })
            .addFunction(xorstr_("turret_aggro_start_time"), [](GameObject* obj) { return g_health_pred_manager->turret_aggro_start_time(obj); })
            .addFunction(xorstr_("aggro_turret"), [](GameObject* obj) { return g_health_pred_manager->get_aggro_turret(obj); })
        .endNamespace();
}

void LuaExporter::export_glow_manager(lua_State* state)
{
    getGlobalNamespace(state)
        .beginNamespace(xorstr_("glow"))
            .addFunction(xorstr_("add"), [](GameObject* obj, uint32_t col, int size, int blur) { return g_glow_manager->register_glow_object(obj, col, size, blur); })
            .addFunction(xorstr_("remove"), [](GameObject* obj) { return g_glow_manager->remove_glow_object(obj); })
            .addFunction(xorstr_("is_glowing"), [](GameObject* obj) { return g_glow_manager->is_glowing(obj); })
        .endNamespace();
}

void LuaExporter::export_permashow(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<Permashow>("permashow")
            .addFunction(xorstr_("add_element"), [](Permashow* self, MenuItem* item, const std::string& name) { return self->add_element(item, name); })
            .addFunction(xorstr_("remove_element"), &Permashow::remove_element_item)
            .addFunction(xorstr_("clear"), &Permashow::clear_elements)
            .addFunction(xorstr_("set_draw"), [] (Permashow* self, MenuItem* item) { self->set_draw(item); })
            .addProperty(xorstr_("name"), &Permashow::get_name)
        .endClass()
        .beginNamespace(xorstr_("permashow_manager"))
            .addFunction(xorstr_("add"), [](Menu* m, const Vec2& pos) { return g_permashow_manager->add_permashow(m, pos); })
            .addFunction(xorstr_("get"), [](const std::string& name) { return g_permashow_manager->get_permashow(name); })
            .addFunction(xorstr_("remove"), [](Permashow* p) { return g_permashow_manager->remove_permashow(p); })
        .endNamespace();
}

void LuaExporter::export_vector(lua_State* state)
{
    getGlobalNamespace(state)
        .beginClass<IntersectionResultVec2>("intersectionresult")
            .addProperty(xorstr_("intersects"), &IntersectionResultVec2::intersects)
            .addProperty(xorstr_("point"), &IntersectionResultVec2::intersection_point)
         .endClass()
        .beginClass<ProjectionInfo>("projectioninfo")
            .addProperty(xorstr_("on_segment"), &ProjectionInfo::is_on_segment)
            .addProperty(xorstr_("line_point"), &ProjectionInfo::line_point)
            .addProperty(xorstr_("segment_point"), &ProjectionInfo::segment_point)
        .endClass()
        .beginClass<Vec3>("vec3")
			.addConstructor<void(*)(float, float, float)>()
            .addProperty(xorstr_("x"), &Vec3::x)
            .addProperty(xorstr_("y"), &Vec3::y)
            .addProperty(xorstr_("z"), &Vec3::z)
            .addFunction(xorstr_("__add"), [](Vec3 v1, const Vec3& v2){ return v1 + v2; })
            .addFunction(xorstr_("__sub"), [](Vec3 v1, const Vec3& v2){ return v1 - v2; })
            .addFunction(xorstr_("__mul"), [](Vec3 v1, const Vec3& v2){ return v1 * v2; })
            .addFunction(xorstr_("__div"), [](Vec3 v1, const Vec3& v2){ return v1 / v2; })
            .addProperty(xorstr_("valid"), &Vec3::is_valid)
            .addFunction(xorstr_("on_screen"), &Vec3::is_on_screen)
            .addFunction(xorstr_("switch_yz"), &Vec3::switch_yz)
            .addFunction(xorstr_("dot"), &Vec3::dot_product)
            .addFunction(xorstr_("cross"), &Vec3::cross_product)
            .addFunction(xorstr_("polar"), &Vec3::polar)
            .addFunction(xorstr_("angle_between"), &Vec3::angle_between)
            .addFunction(xorstr_("close"), &Vec3::close)
            .addFunction(xorstr_("rotated"), &Vec3::rotated)
            .addFunction(xorstr_("perpendicular"), &Vec3::perpendicular)
            .addFunction(xorstr_("append"), &Vec3::append)
            .addFunction(xorstr_("clone"), &Vec3::clone)
            .addFunction(xorstr_("length"), &Vec3::length)
            .addFunction(xorstr_("length_squared"), &Vec3::length_squared)
            .addFunction(xorstr_("distance"), &Vec3::distance)
            .addFunction(xorstr_("distance_squared"), &Vec3::distance_squared)
            .addFunction(xorstr_("extend"), &Vec3::extend)
            .addFunction(xorstr_("scale"), &Vec3::scale)
            .addFunction(xorstr_("rotate"), &Vec3::rotate)
            .addFunction(xorstr_("rotate_x"), &Vec3::rotate_x)
            .addFunction(xorstr_("rotate_y"), &Vec3::rotate_y)
            .addFunction(xorstr_("rotate_z"), &Vec3::rotate_z)
            .addFunction(xorstr_("normalized"), &Vec3::normalized)
            .addFunction(xorstr_("set_height"), &Vec3::set_height)
            .addFunction(xorstr_("to_2d"), &Vec3::to_2d)
            .addFunction(xorstr_("to_world"), [](Vec3 v) { return g_renderer->world_to_screen(v); })
    .endClass()
        .beginClass<Vec2>("vec2")
	        .addConstructor<void(*)(float, float)>()
            .addProperty(xorstr_("x"), &Vec2::x)
            .addProperty(xorstr_("y"), &Vec2::y)
            .addFunction(xorstr_("__add"), [](Vec2 v1, const Vec2& v2){ return v1 + v2; })
            .addFunction(xorstr_("__sub"), [](Vec2 v1, const Vec2& v2){ return v1 - v2; })
            .addFunction(xorstr_("__mul"), [](Vec2 v1, const Vec2& v2){ return v1 * v2; })
            .addFunction(xorstr_("__div"), [](Vec2 v1, const Vec2& v2){ return v1 / v2; })
            .addProperty(xorstr_("valid"), &Vec2::is_valid)
            .addFunction(xorstr_("on_screen"), &Vec2::is_visible_on_screen)
            .addFunction(xorstr_("length"), &Vec2::length)
            .addFunction(xorstr_("length_squared"), &Vec2::length_squared)
            .addFunction(xorstr_("distance"), &Vec2::distance)
            .addFunction(xorstr_("distance_squared"), &Vec2::distance_squared)
            .addFunction(xorstr_("v_scale"), &Vec2::v_scale)
            .addFunction(xorstr_("scale"), &Vec2::scale)
            .addFunction(xorstr_("normalized"), &Vec2::normalized)
            .addFunction(xorstr_("append"), &Vec2::append)
            .addFunction(xorstr_("rotated"), &Vec2::rotated)
            .addFunction(xorstr_("clone"), &Vec2::clone)
            .addFunction(xorstr_("polar"), &Vec2::polar)
            .addFunction(xorstr_("cross_product"), &Vec2::cross_product)
            .addFunction(xorstr_("angle_between"), &Vec2::angle_between)
            .addFunction(xorstr_("intersection"), &Vec2::intersection)
            .addFunction(xorstr_("project_on"), &Vec2::project_on)
            .addFunction(xorstr_("extend"), &Vec2::extend)
            .addFunction(xorstr_("to_3d"), &Vec2::to_3d)
        .endClass();
}

void LuaExporter::export_enums(lua_State* state)
{
	getGlobalNamespace(state)
		.beginNamespace(xorstr_("bufftype"))
			.addProperty(xorstr_("Internal"), [] () { return (int) Enums::BuffType::Internal; })
	        .addProperty(xorstr_("Aura"), [] () { return (int) Enums::BuffType::Aura; })
	        .addProperty(xorstr_("CombatEnchancer"), [] () { return (int) Enums::BuffType::CombatEnchancer; })
	        .addProperty(xorstr_("CombatDehancer"), [] () { return (int) Enums::BuffType::CombatDehancer; })
	        .addProperty(xorstr_("SpellShield"), [] () { return (int) Enums::BuffType::SpellShield; })
	        .addProperty(xorstr_("Stun"), [] () { return (int) Enums::BuffType::Stun; })
	        .addProperty(xorstr_("Invisibility"), [] () { return (int) Enums::BuffType::Invisibility; })
	        .addProperty(xorstr_("Silence"), [] () { return (int) Enums::BuffType::Silence; })
	        .addProperty(xorstr_("Taunt"), [] () { return (int) Enums::BuffType::Taunt; })
	        .addProperty(xorstr_("Berserk"), [] () { return (int) Enums::BuffType::Berserk; })
	        .addProperty(xorstr_("Polymorph"), [] () { return (int) Enums::BuffType::Polymorph; })
	        .addProperty(xorstr_("Slow"), [] () { return (int) Enums::BuffType::Slow; })
	        .addProperty(xorstr_("Snare"), [] () { return (int) Enums::BuffType::Snare; })
	        .addProperty(xorstr_("Damage"), [] () { return (int) Enums::BuffType::Damage; })
	        .addProperty(xorstr_("Heal"), [] () { return (int) Enums::BuffType::Heal; })
	        .addProperty(xorstr_("Haste"), [] () { return (int) Enums::BuffType::Haste; })
	        .addProperty(xorstr_("SpellImmunity"), [] () { return (int) Enums::BuffType::SpellImmunity; })
	        .addProperty(xorstr_("PhysicalImmunity"), [] () { return (int) Enums::BuffType::PhysicalImmunity; })
	        .addProperty(xorstr_("Invulnerability"), [] () { return (int) Enums::BuffType::Invulnerability; })
	        .addProperty(xorstr_("AttackSpeedSlow"), [] () { return (int) Enums::BuffType::AttackSpeedSlow; })
	        .addProperty(xorstr_("NearSight"), [] () { return (int) Enums::BuffType::NearSight; })
	        .addProperty(xorstr_("Currency"), [] () { return (int) Enums::BuffType::Currency; })
	        .addProperty(xorstr_("Fear"), [] () { return (int) Enums::BuffType::Fear; })
	        .addProperty(xorstr_("Charm"), [] () { return (int) Enums::BuffType::Charm; })
	        .addProperty(xorstr_("Poison"), [] () { return (int) Enums::BuffType::Poison; })
	        .addProperty(xorstr_("Suppression"), [] () { return (int) Enums::BuffType::Suppression; })
	        .addProperty(xorstr_("Blind"), [] () { return (int) Enums::BuffType::Blind; })
	        .addProperty(xorstr_("Counter"), [] () { return (int) Enums::BuffType::Counter; })
	        .addProperty(xorstr_("Shred"), [] () { return (int) Enums::BuffType::Shred; })
	        .addProperty(xorstr_("Flee"), [] () { return (int) Enums::BuffType::Flee; })
	        .addProperty(xorstr_("Knockup"), [] () { return (int) Enums::BuffType::Knockup; })
	        .addProperty(xorstr_("Knockback"), [] () { return (int) Enums::BuffType::Knockback; })
	        .addProperty(xorstr_("Disarm"), [] () { return (int) Enums::BuffType::Disarm; })
	        .addProperty(xorstr_("Grounded"), [] () { return (int) Enums::BuffType::Grounded; })
	        .addProperty(xorstr_("Drowsy"), [] () { return (int) Enums::BuffType::Drowsy; })
	        .addProperty(xorstr_("Asleep"), [] () { return (int) Enums::BuffType::Asleep; })
	        .addProperty(xorstr_("Obscured"), [] () { return (int) Enums::BuffType::Obscured; })
	        .addProperty(xorstr_("ClickproofToEnemies"), [] () { return (int) Enums::BuffType::ClickproofToEnemies; })
			.addProperty(xorstr_("UnKillable"), []() { return (int)Enums::BuffType::UnKillable; })
		.endNamespace()
		.beginNamespace(xorstr_("cellflag"))
            .addProperty(xorstr_("None"), []() { return (int) Enums::CollisionFlags::None; })
        .addProperty(xorstr_("Grass"), []() { return (int) Enums::CollisionFlags::Grass; })
        .addProperty(xorstr_("Wall"), []() { return (int) Enums::CollisionFlags::Wall; })
        .addProperty(xorstr_("Building"), []() { return (int) Enums::CollisionFlags::Building; })
        .addProperty(xorstr_("Prop"), []() { return (int) Enums::CollisionFlags::Prop; })
        .addProperty(xorstr_("GlobalVision"), []() { return (int) Enums::CollisionFlags::GlobalVision; })
		.endNamespace()
		.beginNamespace(xorstr_("itemid"))
			.addProperty(xorstr_("Unknown"), []() { return (int) Enums::ItemId::Unknown; })
        .addProperty(xorstr_("Boots"), []() { return (int) Enums::ItemId::Boots; })
        .addProperty(xorstr_("Faerie_Charm"), []() { return (int) Enums::ItemId::Faerie_Charm; })
        .addProperty(xorstr_("Rejuvenation_Bead"), []() { return (int) Enums::ItemId::Rejuvenation_Bead; })
        .addProperty(xorstr_("Giants_Belt"), []() { return (int) Enums::ItemId::Giants_Belt; })
        .addProperty(xorstr_("Cloak_of_Agility"), []() { return (int) Enums::ItemId::Cloak_of_Agility; })
        .addProperty(xorstr_("Blasting_Wand"), []() { return (int) Enums::ItemId::Blasting_Wand; })
        .addProperty(xorstr_("Sapphire_Crystal"), []() { return (int) Enums::ItemId::Sapphire_Crystal; })
        .addProperty(xorstr_("Ruby_Crystal"), []() { return (int) Enums::ItemId::Ruby_Crystal; })
        .addProperty(xorstr_("Cloth_Armor"), []() { return (int) Enums::ItemId::Cloth_Armor; })
        .addProperty(xorstr_("Chain_Vest"), []() { return (int) Enums::ItemId::Chain_Vest; })
        .addProperty(xorstr_("Null_Magic_Mantle"), []() { return (int) Enums::ItemId::Null_Magic_Mantle; })
        .addProperty(xorstr_("Emberknife"), []() { return (int) Enums::ItemId::Emberknife; })
        .addProperty(xorstr_("Long_Sword"), []() { return (int) Enums::ItemId::Long_Sword; })
        .addProperty(xorstr_("Pickaxe"), []() { return (int) Enums::ItemId::Pickaxe; })
        .addProperty(xorstr_("B_F_Sword"), []() { return (int) Enums::ItemId::B_F_Sword; })
        .addProperty(xorstr_("Hailblade"), []() { return (int) Enums::ItemId::Hailblade; })
        .addProperty(xorstr_("Dagger"), []() { return (int) Enums::ItemId::Dagger; })
        .addProperty(xorstr_("Recurve_Bow"), []() { return (int) Enums::ItemId::Recurve_Bow; })
        .addProperty(xorstr_("Amplifying_Tome"), []() { return (int) Enums::ItemId::Amplifying_Tome; })
        .addProperty(xorstr_("Vampiric_Scepter"), []() { return (int) Enums::ItemId::Vampiric_Scepter; })
        .addProperty(xorstr_("Dorans_Shield"), []() { return (int) Enums::ItemId::Dorans_Shield; })
        .addProperty(xorstr_("Dorans_Blade"), []() { return (int) Enums::ItemId::Dorans_Blade; })
        .addProperty(xorstr_("Dorans_Ring"), []() { return (int) Enums::ItemId::Dorans_Ring; })
        .addProperty(xorstr_("Negatron_Cloak"), []() { return (int) Enums::ItemId::Negatron_Cloak; })
        .addProperty(xorstr_("Needlessly_Large_Rod"), []() { return (int) Enums::ItemId::Needlessly_Large_Rod; })
        .addProperty(xorstr_("Dark_Seal"), []() { return (int) Enums::ItemId::Dark_Seal; })
        .addProperty(xorstr_("Cull"), []() { return (int) Enums::ItemId::Cull; })
        .addProperty(xorstr_("Health_Potion"), []() { return (int) Enums::ItemId::Health_Potion; })
        .addProperty(xorstr_("Total_Biscuit_of_Everlasting_Will"), []() { return (int) Enums::ItemId::Total_Biscuit_of_Everlasting_Will; })
        .addProperty(xorstr_("Kircheis_Shard"), []() { return (int) Enums::ItemId::Kircheis_Shard; })
        .addProperty(xorstr_("Refillable_Potion"), []() { return (int) Enums::ItemId::Refillable_Potion; })
        .addProperty(xorstr_("Corrupting_Potion"), []() { return (int) Enums::ItemId::Corrupting_Potion; })
        .addProperty(xorstr_("Guardians_Horn"), []() { return (int) Enums::ItemId::Guardians_Horn; })
        .addProperty(xorstr_("Poro_Snax"), []() { return (int) Enums::ItemId::Poro_Snax; })
        .addProperty(xorstr_("Control_Ward"), []() { return (int) Enums::ItemId::Control_Ward; })
        .addProperty(xorstr_("Shurelyas_Battlesong"), []() { return (int) Enums::ItemId::Shurelyas_Battlesong; })
        .addProperty(xorstr_("Elixir_of_Iron"), []() { return (int) Enums::ItemId::Elixir_of_Iron; })
        .addProperty(xorstr_("Elixir_of_Sorcery"), []() { return (int) Enums::ItemId::Elixir_of_Sorcery; })
        .addProperty(xorstr_("Elixir_of_Wrath"), []() { return (int) Enums::ItemId::Elixir_of_Wrath; })
        .addProperty(xorstr_("Minion_Dematerializer"), []() { return (int) Enums::ItemId::Minion_Dematerializer; })
        .addProperty(xorstr_("Commencing_Stopwatch"), []() { return (int) Enums::ItemId::Commencing_Stopwatch; })
        .addProperty(xorstr_("Stopwatch"), []() { return (int) Enums::ItemId::Stopwatch; })
        .addProperty(xorstr_("Broken_Stopwatch"), []() { return (int) Enums::ItemId::Broken_Stopwatch; })
        .addProperty(xorstr_("Slightly_Magical_Footware"), []() { return (int) Enums::ItemId::Slightly_Magical_Footware; })
        .addProperty(xorstr_("Perfectly_Timed_Stopwatch"), []() { return (int) Enums::ItemId::Perfectly_Timed_Stopwatch; })
        .addProperty(xorstr_("Abyssal_Mask"), []() { return (int) Enums::ItemId::Abyssal_Mask; })
        .addProperty(xorstr_("Archangels_Staff"), []() { return (int) Enums::ItemId::Archangels_Staff; })
        .addProperty(xorstr_("Manamune"), []() { return (int) Enums::ItemId::Manamune; })
        .addProperty(xorstr_("Berserkers_Greaves"), []() { return (int) Enums::ItemId::Berserkers_Greaves; })
        .addProperty(xorstr_("Boots_of_Swiftness"), []() { return (int) Enums::ItemId::Boots_of_Swiftness; })
        .addProperty(xorstr_("Chemtech_Putrifier"), []() { return (int) Enums::ItemId::Chemtech_Putrifier; })
        .addProperty(xorstr_("Sorcerers_Shoes"), []() { return (int) Enums::ItemId::Sorcerers_Shoes; })
        .addProperty(xorstr_("Glacial_Buckler"), []() { return (int) Enums::ItemId::Glacial_Buckler; })
        .addProperty(xorstr_("Guardian_Angel"), []() { return (int) Enums::ItemId::Guardian_Angel; })
        .addProperty(xorstr_("Infinity_Edge"), []() { return (int) Enums::ItemId::Infinity_Edge; })
        .addProperty(xorstr_("Mortal_Reminder"), []() { return (int) Enums::ItemId::Mortal_Reminder; })
        .addProperty(xorstr_("Last_Whisper"), []() { return (int) Enums::ItemId::Last_Whisper; })
        .addProperty(xorstr_("Lord_Dominiks_Regards"), []() { return (int) Enums::ItemId::Lord_Dominiks_Regards; })
        .addProperty(xorstr_("Mejais_Soulstealer"), []() { return (int) Enums::ItemId::Mejais_Soulstealer; })
        .addProperty(xorstr_("Muramana"), []() { return (int) Enums::ItemId::Muramana; })
        .addProperty(xorstr_("Phage"), []() { return (int) Enums::ItemId::Phage; })
        .addProperty(xorstr_("Phantom_Dancer"), []() { return (int) Enums::ItemId::Phantom_Dancer; })
        .addProperty(xorstr_("Plated_Steelcaps"), []() { return (int) Enums::ItemId::Plated_Steelcaps; })
        .addProperty(xorstr_("Seraphs_Embrace"), []() { return (int) Enums::ItemId::Seraphs_Embrace; })
        .addProperty(xorstr_("Zekes_Convergence"), []() { return (int) Enums::ItemId::Zekes_Convergence; })
        .addProperty(xorstr_("Hearthbound_Axe"), []() { return (int) Enums::ItemId::Hearthbound_Axe; })
        .addProperty(xorstr_("Steraks_Gage"), []() { return (int) Enums::ItemId::Steraks_Gage; })
        .addProperty(xorstr_("Sheen"), []() { return (int) Enums::ItemId::Sheen; })
        .addProperty(xorstr_("Spirit_Visage"), []() { return (int) Enums::ItemId::Spirit_Visage; })
        .addProperty(xorstr_("Winged_Moonplate"), []() { return (int) Enums::ItemId::Winged_Moonplate; })
        .addProperty(xorstr_("Kindlegem"), []() { return (int) Enums::ItemId::Kindlegem; })
        .addProperty(xorstr_("Sunfire_Aegis"), []() { return (int) Enums::ItemId::Sunfire_Aegis; })
        .addProperty(xorstr_("Tear_of_the_Goddess"), []() { return (int) Enums::ItemId::Tear_of_the_Goddess; })
        .addProperty(xorstr_("Black_Cleaver"), []() { return (int) Enums::ItemId::Black_Cleaver; })
        .addProperty(xorstr_("Bloodthirster"), []() { return (int) Enums::ItemId::Bloodthirster; })
        .addProperty(xorstr_("Ravenous_Hydra"), []() { return (int) Enums::ItemId::Ravenous_Hydra; })
        .addProperty(xorstr_("Thornmail"), []() { return (int) Enums::ItemId::Thornmail; })
        .addProperty(xorstr_("Bramble_Vest"), []() { return (int) Enums::ItemId::Bramble_Vest; })
        .addProperty(xorstr_("Tiamat"), []() { return (int) Enums::ItemId::Tiamat; })
        .addProperty(xorstr_("Trinity_Force"), []() { return (int) Enums::ItemId::Trinity_Force; })
        .addProperty(xorstr_("Wardens_Mail"), []() { return (int) Enums::ItemId::Wardens_Mail; })
        .addProperty(xorstr_("Warmogs_Armor"), []() { return (int) Enums::ItemId::Warmogs_Armor; })
        .addProperty(xorstr_("Runaans_Hurricane"), []() { return (int) Enums::ItemId::Runaans_Hurricane; })
        .addProperty(xorstr_("Zeal"), []() { return (int) Enums::ItemId::Zeal; })
        .addProperty(xorstr_("Rabadons_Deathcap"), []() { return (int) Enums::ItemId::Rabadons_Deathcap; })
        .addProperty(xorstr_("Wits_End"), []() { return (int) Enums::ItemId::Wits_End; })
        .addProperty(xorstr_("Rapid_Firecannon"), []() { return (int) Enums::ItemId::Rapid_Firecannon; })
        .addProperty(xorstr_("Stormrazor"), []() { return (int) Enums::ItemId::Stormrazor; })
        .addProperty(xorstr_("Lich_Bane"), []() { return (int) Enums::ItemId::Lich_Bane; })
        .addProperty(xorstr_("Banshees_Veil"), []() { return (int) Enums::ItemId::Banshees_Veil; })
        .addProperty(xorstr_("Aegis_of_the_Legion"), []() { return (int) Enums::ItemId::Aegis_of_the_Legion; })
        .addProperty(xorstr_("Redemption"), []() { return (int) Enums::ItemId::Redemption; })
        .addProperty(xorstr_("Fiendish_Codex"), []() { return (int) Enums::ItemId::Fiendish_Codex; })
        .addProperty(xorstr_("Knights_Vow"), []() { return (int) Enums::ItemId::Knights_Vow; })
        .addProperty(xorstr_("Frozen_Heart"), []() { return (int) Enums::ItemId::Frozen_Heart; })
        .addProperty(xorstr_("Mercurys_Treads"), []() { return (int) Enums::ItemId::Mercurys_Treads; })
        .addProperty(xorstr_("Guardians_Orb"), []() { return (int) Enums::ItemId::Guardians_Orb; })
        .addProperty(xorstr_("Aether_Wisp"), []() { return (int) Enums::ItemId::Aether_Wisp; })
        .addProperty(xorstr_("Forbidden_Idol"), []() { return (int) Enums::ItemId::Forbidden_Idol; })
        .addProperty(xorstr_("Nashors_Tooth"), []() { return (int) Enums::ItemId::Nashors_Tooth; })
        .addProperty(xorstr_("Rylais_Crystal_Scepter"), []() { return (int) Enums::ItemId::Rylais_Crystal_Scepter; })
        .addProperty(xorstr_("Mobility_Boots"), []() { return (int) Enums::ItemId::Mobility_Boots; })
        .addProperty(xorstr_("Executioners_Calling"), []() { return (int) Enums::ItemId::Executioners_Calling; })
        .addProperty(xorstr_("Guinsoos_Rageblade"), []() { return (int) Enums::ItemId::Guinsoos_Rageblade; })
        .addProperty(xorstr_("Caulfields_Warhammer"), []() { return (int) Enums::ItemId::Caulfields_Warhammer; })
        .addProperty(xorstr_("Serrated_Dirk"), []() { return (int) Enums::ItemId::Serrated_Dirk; })
        .addProperty(xorstr_("Void_Staff"), []() { return (int) Enums::ItemId::Void_Staff; })
        .addProperty(xorstr_("Mercurial_Scimitar"), []() { return (int) Enums::ItemId::Mercurial_Scimitar; })
        .addProperty(xorstr_("Quicksilver_Sash"), []() { return (int) Enums::ItemId::Quicksilver_Sash; })
        .addProperty(xorstr_("Youmuus_Ghostblade"), []() { return (int) Enums::ItemId::Youmuus_Ghostblade; })
        .addProperty(xorstr_("Randuins_Omen"), []() { return (int) Enums::ItemId::Randuins_Omen; })
        .addProperty(xorstr_("Hextech_Alternator"), []() { return (int) Enums::ItemId::Hextech_Alternator; })
        .addProperty(xorstr_("Hextech_Rocketbelt"), []() { return (int) Enums::ItemId::Hextech_Rocketbelt; })
        .addProperty(xorstr_("Blade_of_the_Ruined_King"), []() { return (int) Enums::ItemId::Blade_of_the_Ruined_King; })
        .addProperty(xorstr_("Hexdrinker"), []() { return (int) Enums::ItemId::Hexdrinker; })
        .addProperty(xorstr_("Maw_of_Malmortius"), []() { return (int) Enums::ItemId::Maw_of_Malmortius; })
        .addProperty(xorstr_("Zhonyas_Hourglass"), []() { return (int) Enums::ItemId::Zhonyas_Hourglass; })
        .addProperty(xorstr_("Ionian_Boots_of_Lucidity"), []() { return (int) Enums::ItemId::Ionian_Boots_of_Lucidity; })
        .addProperty(xorstr_("Morellonomicon"), []() { return (int) Enums::ItemId::Morellonomicon; })
        .addProperty(xorstr_("Guardians_Blade"), []() { return (int) Enums::ItemId::Guardians_Blade; })
        .addProperty(xorstr_("Umbral_Glaive"), []() { return (int) Enums::ItemId::Umbral_Glaive; })
        .addProperty(xorstr_("Sanguine_Blade"), []() { return (int) Enums::ItemId::Sanguine_Blade; })
        .addProperty(xorstr_("Guardians_Hammer"), []() { return (int) Enums::ItemId::Guardians_Hammer; })
        .addProperty(xorstr_("Locket_of_the_Iron_Solari"), []() { return (int) Enums::ItemId::Locket_of_the_Iron_Solari; })
        .addProperty(xorstr_("Seekers_Armguard"), []() { return (int) Enums::ItemId::Seekers_Armguard; })
        .addProperty(xorstr_("Gargoyle_Stoneplate"), []() { return (int) Enums::ItemId::Gargoyle_Stoneplate; })
        .addProperty(xorstr_("Spectres_Cowl"), []() { return (int) Enums::ItemId::Spectres_Cowl; })
        .addProperty(xorstr_("Mikaels_Blessing"), []() { return (int) Enums::ItemId::Mikaels_Blessing; })
        .addProperty(xorstr_("Scarecrow_Effigy"), []() { return (int) Enums::ItemId::Scarecrow_Effigy; })
        .addProperty(xorstr_("Stealth_Ward"), []() { return (int) Enums::ItemId::Stealth_Ward; })
        .addProperty(xorstr_("Farsight_Alteration"), []() { return (int) Enums::ItemId::Farsight_Alteration; })
        .addProperty(xorstr_("Oracle_Lens"), []() { return (int) Enums::ItemId::Oracle_Lens; })
        .addProperty(xorstr_("Your_Cut"), []() { return (int) Enums::ItemId::Your_Cut; })
        .addProperty(xorstr_("Ardent_Censer"), []() { return (int) Enums::ItemId::Ardent_Censer; })
        .addProperty(xorstr_("Essence_Reaver"), []() { return (int) Enums::ItemId::Essence_Reaver; })
        .addProperty(xorstr_("Eye_of_the_Herald"), []() { return (int) Enums::ItemId::Eye_of_the_Herald; })
        .addProperty(xorstr_("Kalistas_Black_Spear"), []() { return (int) Enums::ItemId::Kalistas_Black_Spear; })
        .addProperty(xorstr_("Dead_Mans_Plate"), []() { return (int) Enums::ItemId::Dead_Mans_Plate; })
        .addProperty(xorstr_("Titanic_Hydra"), []() { return (int) Enums::ItemId::Titanic_Hydra; })
        .addProperty(xorstr_("Crystalline_Bracer"), []() { return (int) Enums::ItemId::Crystalline_Bracer; })
        .addProperty(xorstr_("Lost_Chapter"), []() { return (int) Enums::ItemId::Lost_Chapter; })
        .addProperty(xorstr_("Edge_of_Night"), []() { return (int) Enums::ItemId::Edge_of_Night; })
        .addProperty(xorstr_("Spellthiefs_Edge"), []() { return (int) Enums::ItemId::Spellthiefs_Edge; })
        .addProperty(xorstr_("Frostfang"), []() { return (int) Enums::ItemId::Frostfang; })
        .addProperty(xorstr_("Shard_of_True_Ice"), []() { return (int) Enums::ItemId::Shard_of_True_Ice; })
        .addProperty(xorstr_("Steel_Shoulderguards"), []() { return (int) Enums::ItemId::Steel_Shoulderguards; })
        .addProperty(xorstr_("Runesteel_Spaulders"), []() { return (int) Enums::ItemId::Runesteel_Spaulders; })
        .addProperty(xorstr_("Pauldrons_of_Whiterock"), []() { return (int) Enums::ItemId::Pauldrons_of_Whiterock; })
        .addProperty(xorstr_("Relic_Shield"), []() { return (int) Enums::ItemId::Relic_Shield; })
        .addProperty(xorstr_("Targons_Buckler"), []() { return (int) Enums::ItemId::Targons_Buckler; })
        .addProperty(xorstr_("Bulwark_of_the_Mountain"), []() { return (int) Enums::ItemId::Bulwark_of_the_Mountain; })
        .addProperty(xorstr_("Spectral_Sickle"), []() { return (int) Enums::ItemId::Spectral_Sickle; })
        .addProperty(xorstr_("Harrowing_Crescent"), []() { return (int) Enums::ItemId::Harrowing_Crescent; })
        .addProperty(xorstr_("Black_Mist_Scythe"), []() { return (int) Enums::ItemId::Black_Mist_Scythe; })
        .addProperty(xorstr_("Oblivion_Orb"), []() { return (int) Enums::ItemId::Oblivion_Orb; })
        .addProperty(xorstr_("Imperial_Mandate"), []() { return (int) Enums::ItemId::Imperial_Mandate; })
        .addProperty(xorstr_("Force_of_Nature"), []() { return (int) Enums::ItemId::Force_of_Nature; })
        .addProperty(xorstr_("The_Golden_Spatula"), []() { return (int) Enums::ItemId::The_Golden_Spatula; })
        .addProperty(xorstr_("Horizon_Focus"), []() { return (int) Enums::ItemId::Horizon_Focus; })
        .addProperty(xorstr_("Cosmic_Drive"), []() { return (int) Enums::ItemId::Cosmic_Drive; })
        .addProperty(xorstr_("Blighting_Jewel"), []() { return (int) Enums::ItemId::Blighting_Jewel; })
        .addProperty(xorstr_("Verdant_Barrier"), []() { return (int) Enums::ItemId::Verdant_Barrier; })
        .addProperty(xorstr_("Riftmaker"), []() { return (int) Enums::ItemId::Riftmaker; })
        .addProperty(xorstr_("Leeching_Leer"), []() { return (int) Enums::ItemId::Leeching_Leer; })
        .addProperty(xorstr_("Night_Harvester"), []() { return (int) Enums::ItemId::Night_Harvester; })
        .addProperty(xorstr_("Demonic_Embrace"), []() { return (int) Enums::ItemId::Demonic_Embrace; })
        .addProperty(xorstr_("Watchful_Wardstone"), []() { return (int) Enums::ItemId::Watchful_Wardstone; })
        .addProperty(xorstr_("Stirring_Wardstone"), []() { return (int) Enums::ItemId::Stirring_Wardstone; })
        .addProperty(xorstr_("Bandleglass_Mirror"), []() { return (int) Enums::ItemId::Bandleglass_Mirror; })
        .addProperty(xorstr_("Vigilant_Wardstone"), []() { return (int) Enums::ItemId::Vigilant_Wardstone; })
        .addProperty(xorstr_("Ironspike_Whip"), []() { return (int) Enums::ItemId::Ironspike_Whip; })
        .addProperty(xorstr_("Silvermere_Dawn"), []() { return (int) Enums::ItemId::Silvermere_Dawn; })
        .addProperty(xorstr_("Deaths_Dance"), []() { return (int) Enums::ItemId::Deaths_Dance; })
        .addProperty(xorstr_("Chempunk_Chainsword"), []() { return (int) Enums::ItemId::Chempunk_Chainsword; })
        .addProperty(xorstr_("Staff_of_Flowing_Water"), []() { return (int) Enums::ItemId::Staff_of_Flowing_Water; })
        .addProperty(xorstr_("Moonstone_Renewer"), []() { return (int) Enums::ItemId::Moonstone_Renewer; })
        .addProperty(xorstr_("Goredrinker"), []() { return (int) Enums::ItemId::Goredrinker; })
        .addProperty(xorstr_("Stridebreaker"), []() { return (int) Enums::ItemId::Stridebreaker; })
        .addProperty(xorstr_("Divine_Sunderer"), []() { return (int) Enums::ItemId::Divine_Sunderer; })
        .addProperty(xorstr_("Liandrys_Anguish"), []() { return (int) Enums::ItemId::Liandrys_Anguish; })
        .addProperty(xorstr_("Ludens_Tempest"), []() { return (int) Enums::ItemId::Ludens_Tempest; })
        .addProperty(xorstr_("Everfrost"), []() { return (int) Enums::ItemId::Everfrost; })
        .addProperty(xorstr_("Bamis_Cinder"), []() { return (int) Enums::ItemId::Bamis_Cinder; })
        .addProperty(xorstr_("Frostfire_Gauntlet"), []() { return (int) Enums::ItemId::Frostfire_Gauntlet; })
        .addProperty(xorstr_("Turbo_Chemtank"), []() { return (int) Enums::ItemId::Turbo_Chemtank; })
        .addProperty(xorstr_("Noonquiver"), []() { return (int) Enums::ItemId::Noonquiver; })
        .addProperty(xorstr_("Galeforce"), []() { return (int) Enums::ItemId::Galeforce; })
        .addProperty(xorstr_("Kraken_Slayer"), []() { return (int) Enums::ItemId::Kraken_Slayer; })
        .addProperty(xorstr_("Immortal_Shieldbow"), []() { return (int) Enums::ItemId::Immortal_Shieldbow; })
        .addProperty(xorstr_("Navori_Quickblades"), []() { return (int) Enums::ItemId::Navori_Quickblades; })
        .addProperty(xorstr_("The_Collector"), []() { return (int) Enums::ItemId::The_Collector; })
        .addProperty(xorstr_("Rageknife"), []() { return (int) Enums::ItemId::Rageknife; })
        .addProperty(xorstr_("Duskblade_of_Draktharr"), []() { return (int) Enums::ItemId::Duskblade_of_Draktharr; })
        .addProperty(xorstr_("Eclipse"), []() { return (int) Enums::ItemId::Eclipse; })
        .addProperty(xorstr_("Prowlers_Claw"), []() { return (int) Enums::ItemId::Prowlers_Claw; })
        .addProperty(xorstr_("Seryldas_Grudge"), []() { return (int) Enums::ItemId::Seryldas_Grudge; })
        .addProperty(xorstr_("Serpents_Fang"), []() { return (int) Enums::ItemId::Serpents_Fang; })
		.endNamespace()
		.beginNamespace(xorstr_("team"))
			.addProperty(xorstr_("Unknown"), [] () { return (int) Enums::GameObjectTeam::Unknown; })
            .addProperty(xorstr_("Blue"), [] () { return (int) Enums::GameObjectTeam::Blue; })
            .addProperty(xorstr_("Red"), [] () { return (int) Enums::GameObjectTeam::Red; })
        .addProperty(xorstr_("Neutral"), []() { return (int)Enums::GameObjectTeam::Neutral; })
		.endNamespace()
		.beginNamespace(xorstr_("object_type"))
            .addProperty(xorstr_("Unknown"), [] () { return (int) Enums::GameObjectType::Unknown; })
            .addProperty(xorstr_("NeutralMinionCamp"), [] () { return (int) Enums::GameObjectType::NeutralMinionCamp; })
            .addProperty(xorstr_("AIHeroClient"), [] () { return (int) Enums::GameObjectType::AIHeroClient; })
            .addProperty(xorstr_("AIMarker"), [] () { return (int) Enums::GameObjectType::AIMarker; })
            .addProperty(xorstr_("AIMinionClient"), [] () { return (int) Enums::GameObjectType::AIMinionClient; })
            .addProperty(xorstr_("ObjectAttacher"), [] () { return (int) Enums::GameObjectType::ObjectAttacher; })
            .addProperty(xorstr_("LevelPropAIClient"), [] () { return (int) Enums::GameObjectType::LevelPropAIClient; })
            .addProperty(xorstr_("AITurretClient"), [] () { return (int) Enums::GameObjectType::AITurretClient; })
            .addProperty(xorstr_("AITurretCommon"), [] () { return (int) Enums::GameObjectType::AITurretCommon; })
            .addProperty(xorstr_("obj_GeneralParticleEmitter"), [] () { return (int) Enums::GameObjectType::obj_GeneralParticleEmitter; })
            .addProperty(xorstr_("GameObject"), [] () { return (int) Enums::GameObjectType::GameObject; })
            .addProperty(xorstr_("MissileClient"), [] () { return (int) Enums::GameObjectType::MissileClient; })
            .addProperty(xorstr_("DrawFX"), [] () { return (int) Enums::GameObjectType::DrawFX; })
            .addProperty(xorstr_("UnrevealedTarget"), [] () { return (int) Enums::GameObjectType::UnrevealedTarget; })
            .addProperty(xorstr_("BarracksDampener"), [] () { return (int) Enums::GameObjectType::BarracksDampener; })
            .addProperty(xorstr_("Barracks"), [] () { return (int) Enums::GameObjectType::Barracks; })
            .addProperty(xorstr_("AnimatedBuilding"), [] () { return (int) Enums::GameObjectType::AnimatedBuilding; })
            .addProperty(xorstr_("BuildingClient"), [] () { return (int) Enums::GameObjectType::BuildingClient; })
            .addProperty(xorstr_("obj_Levelsizer"), [] () { return (int) Enums::GameObjectType::obj_Levelsizer; })
            .addProperty(xorstr_("obj_NavPoint"), [] () { return (int) Enums::GameObjectType::obj_NavPoint; })
            .addProperty(xorstr_("obj_SpawnPoint"), [] () { return (int) Enums::GameObjectType::obj_SpawnPoint; })
            .addProperty(xorstr_("GrassObject"), [] () { return (int) Enums::GameObjectType::GrassObject; })
            .addProperty(xorstr_("HQ"), [] () { return (int) Enums::GameObjectType::HQ; })
            .addProperty(xorstr_("obj_InfoPoint"), [] () { return (int) Enums::GameObjectType::obj_InfoPoint; })
            .addProperty(xorstr_("LevelPropGameObject"), [] () { return (int) Enums::GameObjectType::LevelPropGameObject; })
            .addProperty(xorstr_("LevelPropSpawnerPoint"), [] () { return (int) Enums::GameObjectType::LevelPropSpawnerPoint; })
            .addProperty(xorstr_("Shop"), [] () { return (int) Enums::GameObjectType::Shop; })
			.addProperty(xorstr_("Turret"), []() { return (int)Enums::GameObjectType::Turret; })
		.endNamespace()
		.beginNamespace(xorstr_("orbmode"))
            .addProperty(xorstr_("None"), [] () { return (int) Enums::OrbwalkerMode::None; })
            .addProperty(xorstr_("Combo"), []() { return (int)Enums::OrbwalkerMode::Combo; })
            .addProperty(xorstr_("LaneClear"), []() { return (int)Enums::OrbwalkerMode::LaneClear; })
            .addProperty(xorstr_("Harass"), []() { return (int)Enums::OrbwalkerMode::Harass; })
            .addProperty(xorstr_("LastHit"), []() { return (int)Enums::OrbwalkerMode::LastHit; })
            .addProperty(xorstr_("Flee"), []() { return (int)Enums::OrbwalkerMode::Flee; })
		.endNamespace()
		.beginNamespace(xorstr_("slotid"))
			.addProperty(xorstr_("Unknown"), [] () { return (int) Enums::SpellSlot::Unknown; })
            .addProperty(xorstr_("Q"), []() { return (int)Enums::SpellSlot::Q; })
            .addProperty(xorstr_("W"), []() { return (int)Enums::SpellSlot::W; })
            .addProperty(xorstr_("E"), []() { return (int)Enums::SpellSlot::E; })
            .addProperty(xorstr_("R"), []() { return (int)Enums::SpellSlot::R; })
            .addProperty(xorstr_("Summoner1"), []() { return (int)Enums::SpellSlot::Summoner1; })
            .addProperty(xorstr_("Summoner2"), []() { return (int)Enums::SpellSlot::Summoner2; })
            .addProperty(xorstr_("Item1"), []() { return (int)Enums::SpellSlot::Item1; })
            .addProperty(xorstr_("Item2"), []() { return (int)Enums::SpellSlot::Item2; })
            .addProperty(xorstr_("Item3"), []() { return (int)Enums::SpellSlot::Item3; })
            .addProperty(xorstr_("Item4"), []() { return (int)Enums::SpellSlot::Item4; })
            .addProperty(xorstr_("Item5"), []() { return (int)Enums::SpellSlot::Item5; })
            .addProperty(xorstr_("Item6"), []() { return (int)Enums::SpellSlot::Item6; })
            .addProperty(xorstr_("Item_Trinket"), []() { return (int)Enums::SpellSlot::Item_Trinket; })
            .addProperty(xorstr_("Recall"), []() { return (int)Enums::SpellSlot::Recall; })
            .addProperty(xorstr_("SpecialAttack"), []() { return (int)Enums::SpellSlot::SpecialAttack; })
            .addProperty(xorstr_("SpecialSpell1"), []() { return (int)Enums::SpellSlot::SpecialSpell1; })
            .addProperty(xorstr_("Auto1"), []() { return (int)Enums::SpellSlot::Auto1; })
            .addProperty(xorstr_("Auto2"), []() { return (int)Enums::SpellSlot::Auto2; })
            .addProperty(xorstr_("Auto3"), []() { return (int)Enums::SpellSlot::Auto3; })
		.endNamespace()
		.beginNamespace(xorstr_("spellstate"))
			.addProperty(xorstr_("Unknown"), [] () { return (int) Enums::SpellState::Unknown; })
            .addProperty(xorstr_("Ready"), []() { return (int)Enums::SpellState::Ready; })
            .addProperty(xorstr_("NotAvailable"), []() { return (int)Enums::SpellState::NotAvailable; })
            .addProperty(xorstr_("Supressed"), []() { return (int)Enums::SpellState::Supressed; })
            .addProperty(xorstr_("NotLearned"), []() { return (int)Enums::SpellState::NotLearned; })
            .addProperty(xorstr_("Channeling"), []() { return (int)Enums::SpellState::Channeling; })
            .addProperty(xorstr_("Cooldown"), []() { return (int)Enums::SpellState::Cooldown; })
            .addProperty(xorstr_("NoMana"), []() { return (int)Enums::SpellState::NoMana; })
		.endNamespace()
		.beginNamespace(xorstr_("damagetype"))
            .addProperty(xorstr_("raw"), [] { return 0; })
			.addProperty(xorstr_("phy"), [] { return 1; })
            .addProperty(xorstr_("mag"), [] { return 2; })
            .addProperty(xorstr_("mix"), [] { return 3; })
		.endNamespace();
}
